# 递归学习笔记

## 什么是递归

* 程序调用自身的编程技巧称为递归（recursion)，是一种非常广泛的变成技巧或者算法。

* 看一个简单的例子：看电影
  去看电影，不知道几排，那么你会问前面的人他是第几排，只要加上1就是你的排号，但是前面的人也不知道他是第几排，所以他也往前问，就这样一排一排往前问。直到你前面的人告诉你他是几排，你就知道了答案。

这就是一个递归的过程，去的工程叫“递”，回的过程叫“归”。基本上所有的递归问题都可以用递推公式来表示。看电影的递推公式为：
>f(n) = f(n-1) + 1, 其中f(1) = 1

可以写成如下的递归代码，也就是递归函数：

```` C
int f(int n) {
   if(n == 1) return 1;
   return f(n-1) + 1;
}
````

上面就是一个递归函数：函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。递归函数不能定义为内联函数。

## 递归需要满足的三个条件

* ***一个问题的解可以分解为几个子问题的解***
  子问题？子问题就是数据规模更小的的问题。如看电影例子中，“自己在哪一排”可以分解成“前一排的人在哪一排”这样一个子问题。

* ***该问题与分解之后的子问题，除了数据规模不同，求解思路完全一样***
  看电影例子中，求解“自己在哪一排”的思路，和前面一排的人求解“自己在哪一排”的思路，是一样的。

* ***存在递归终止条件(边界条件)***
  把问题分解成子问题，子问题再分解为子问题，一层一层的分解下去，但不能存在无限循环，需要有终止条件(边界条件)，看电影问题中边界条件就是f(1) = 1。

**综上，写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再敲定终止条件，最后将递推公式和终止条件翻译成代码。**

## 如何思考递归

很少有像看电影这么简单的情况，所以靠人脑去想象整个递归的过程对于比较复杂的问题来说，基本是不可能的，所以如何以正确的思维来思考递归就很重要，那那种思维呢？

>如果一个问题A可以分解为若干子问题B、C、D，可以**假设子问题B、C、D已经解决**，在此基础上思考如何解决问题A。而且**只需要思考问题A与子问题B、C、D两层之间的关系即可**，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归的过程，这样子理解起来就会更简单。

所以遇到递归问题，把其抽象成一个递推公式，不用想一层层的调用关系。

## 写递归代码需要注意的问题及解决方案

* 警惕堆栈溢出
  可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出，但是最大允许的递归深度跟当前线程的栈空间大小有关，事先无法计算。
* 警惕重复计算(非常容易发生)
  ![重复计算的例子](./pic/递归重复计算.jpg)
  可以看出来，计算f(5)重复计算的f(3)两次，f(2)三次。可以通过散列表等某种数据结构来记保存求解过的值，从而避免重复计算。
* 建议把递归写成递推式

## 递归的优缺点

* 优点：代码表达能力强，写起来简洁。
* 缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等。
